<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/28/%E8%A1%8C%E6%80%9D%E5%A0%82%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E8%AF%B4%E6%98%8E/"/>
    <url>/2024/06/28/%E8%A1%8C%E6%80%9D%E5%A0%82%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="gitee代码托管平台的基本使用与操作"><a href="#gitee代码托管平台的基本使用与操作" class="headerlink" title="gitee代码托管平台的基本使用与操作"></a>gitee代码托管平台的基本使用与操作</h1><h2 id="0-预置环境"><a href="#0-预置环境" class="headerlink" title="0. 预置环境"></a>0. 预置环境</h2><ul><li><p>本地安装git</p></li><li><p>确定自己对仓库的权限申请是否批准</p></li></ul><h2 id="1-Git-全局设置"><a href="#1-Git-全局设置" class="headerlink" title="1.Git 全局设置"></a>1.Git 全局设置</h2><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;xingkong1010&quot;<br>git config --global user.email &quot;630361560@qq.com&quot;<br></code></pre></td></tr></table></figure><h2 id="2-本地仓库配置-配置过直接跳转第3步"><a href="#2-本地仓库配置-配置过直接跳转第3步" class="headerlink" title="2. 本地仓库配置(配置过直接跳转第3步)"></a>2. 本地仓库配置(配置过直接跳转第3步)</h2><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">&quot;&quot;&quot;<br>创建 git 仓库<br>&quot;&quot;&quot;<br>git clone https://gitee.com/jhl1010/minisns_front_621.git<br>cd minisns_front_621<br>git remote add origin https://gitee.com/jhl1010/minisns_front_621.git <br></code></pre></td></tr></table></figure><h2 id="3-代码提交"><a href="#3-代码提交" class="headerlink" title="3. 代码提交"></a>3. 代码提交</h2><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git add .     //将代码添加到本地仓库, &quot;.&quot;表示全部<br>git commit -m &quot;改动说明&quot;    // 提交代码到本地仓库<br>git push    // 推送本次添加操作到远程仓库<br></code></pre></td></tr></table></figure><h2 id="4-详细命令参考"><a href="#4-详细命令参考" class="headerlink" title="4. 详细命令参考"></a>4. 详细命令参考</h2><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git"><br>git status    // 查看文件状态<br>git diff &lt;文件名&gt;    // 查看文件内容修改<br>git log    // 查看提交记录<br><br>jhl1010<br>3574794e500911387567ab5c8b62c7ca<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习总结】雅思写作</title>
    <link href="/2024/03/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%91%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/"/>
    <url>/2024/03/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%91%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<img src="https://s2.loli.net/2024/03/14/GT9p3RaH6CXODIK.png" alt="image-20240314210557569" style="zoom:50%;" /><h2 id="Lesson-1-overview"><a href="#Lesson-1-overview" class="headerlink" title="Lesson 1- overview"></a>Lesson 1- overview</h2><p> Just remember task 1 is to describe what you see. Don’t give any opinions. So write a summary(overview) instead of conclusion.</p><ol><li>Question  Types</li></ol><p>The  question types can be defined into six types: line graph、bar chart、pie chart、table、diagram-comparing、diagram-process(map questions are included in diagrams). And the first four types have one thing in common, that they all show numbers. What you should do is just to describe one specific number, to compare some numbers and to describe the trends&#x2F;changes. However, the fifth type is almost similar except description of the number.</p><ol><li>Essay Structure</li></ol><p>The four paragraphs structure.</p><ol><li>Introduction – Paraphrase the question</li><li>Summary – The main, general things</li><li>Details</li><li>Details</li></ol><h2 id="Lesson-2-line-graph"><a href="#Lesson-2-line-graph" class="headerlink" title="Lesson 2 - line graph"></a>Lesson 2 - line graph</h2><p> It shows the number changing over a period of time.</p><p> First, make a very general comparison. Such as higher overall</p><p> Second, compare the lines at specific points.</p><p> Example:</p><p><img src="https://zxj921pynq.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU2MGFmMDVjZDFjNmQ3ZjFkOTBmYThlZmUwMzA0OGNfTDlhem1ScFFGYjRhMXhhaEV0NlAyN2dBSWdDZVJTb0dfVG9rZW46UWd3TGJuT1B1b2x2Wmd4RFhmUGNROFlGbnlmXzE3MTA0MjE0Nzg6MTcxMDQyNTA3OF9WNA" alt="img"></p><p><strong>The graph below shows electricity production (in terawatt hours) in France between 1980 and 2012.</strong></p><p><strong>Introduction</strong></p><p>The line graph compares the amount of electricity produced in France using four different sources of power over a period of 32 years.</p><p><img src="https://zxj921pynq.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E2ZjFkMGNmYTEyODNhMTBkYzJmNDhiZTY4NzE1NmRfTlh2RDI5QWlaUm5JUEFVd0E2VG1VRlcxbVJrRExtUlZfVG9rZW46VndUd2JuM2c2b3VhYzB4WVI2c2M0TnFubkplXzE3MTA0MjE0Nzg6MTcxMDQyNTA3OF9WNA" alt="img"></p><p>It is clear that nuclear power was by far the most important means of electricity generation over the period shown. Renewables provided the lowest amount of electricity in each year.</p><p><img src="https://zxj921pynq.feishu.cn/space/api/box/stream/download/asynccode/?code=NDc5ZjUzZjkyNTZiMmQwN2U1M2FjMjIzYjMxMWQwYTJfVXE2RFNPS2xyeXcyOXhFQ0hIQ0k5ZERiRUxSclhrNkJfVG9rZW46RXEzRmJzRDJzb05NbWZ4WFQzN2NwMUdwbnZmXzE3MTA0MjE0Nzg6MTcxMDQyNTA3OF9WNA" alt="img"></p><p>In 1980, thermal power stations were the main source of electricity in France, generating around 120 terawatt hours of power. Nuclear and hydroelectric power stations produced just under 75 terawatt hours of electricity each, and renewables provided a negligible amount. Just one year later, nuclear power overtook thermal power as the primary source of electricity.</p><p><img src="https://zxj921pynq.feishu.cn/space/api/box/stream/download/asynccode/?code=NDdhYWMwMGM2NDQyMWEzMGNiMzY5ZjMwMTk2M2ZjZGRfSTAzbFMwc3pmVmFRaE5LZDJid1FkT2dsSEtWN1BoZzdfVG9rZW46SU1pWGJnVVZDb3hIdUJ4a3k1N2NGVlVWbnhjXzE3MTA0MjE0Nzg6MTcxMDQyNTA3OF9WNA" alt="img"></p><p>Between 1980 and 2005,electricity production from nuclear power rose dramatically to a peak of 430 terawatt hours. By contrast,the figure for thermal power fell to only 50 terawatt hours in 1985,and remained at this level for the rest of the period. Hydroelectric power generation remained relatively stable,at between 50 and 80 terawatt hours,for the whole 32-year period,but renewable electricity production saw only a small rise to approximately 25 terawatt hours by 2012.</p><p>amount of electricity produced</p><p>source of provided generating</p><p>means of electricity generation</p><p>over a period of &#x2F;over the period shown</p><p>by far the most important</p><p>a negligible amount</p><p>nuclear power overtook thermal power</p><p>as the primary source of electricity</p><p>rose dramatically to a peak of</p><p>by contrast</p><p>the figure for</p><p>remained at this level,remained stable</p><p>saw only a small rise</p>]]></content>
    
    
    
    <tags>
      
      <tag>雅思</tag>
      
      <tag>写作</tag>
      
      <tag>Simon写作课</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于延迟的带宽估计</title>
    <link href="/2024/03/07/%E5%9F%BA%E4%BA%8E%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%B8%A6%E5%AE%BD%E4%BC%B0%E8%AE%A1/"/>
    <url>/2024/03/07/%E5%9F%BA%E4%BA%8E%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%B8%A6%E5%AE%BD%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=YzUxODYzMTU0ZjY5M2VjOGJmOGFkOTdhNjc0NzQ0MTFfS0x6VHBKcDExQmo2YThsaUJJVGJEdFNLZjNqZ3lGNERfVG9rZW46TEhFY2Jub0NRb2JLOGJ4N3ZOSmNpZWpsbmpsXzE3MDk4MDUyNzI6MTcwOTgwODg3Ml9WNA" alt="img"></p><p>通过Transport feedback包统计发送时间和到达时间，并通过这些信息统计计算包组延迟差，通过延迟差估计延迟变化趋势，通过这个趋势和给定阈值的比较来判断链路状态，在检测状态的同时阈值也在自适应的变化。然后通过检测的链路状态，通过状态机进行状态的变化以及在对应状态进行对应的码率控制逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\goog_cc_network_controller.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xrtc/rtc/pc/network_controller.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xrtc/rtc/modules/congestion_controller/goog_cc/delay_based_bwe.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> xrtc &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoogCcNetworkController</span> : <span class="hljs-keyword">public</span> NetworkControllerInterface &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GoogCcNetworkController</span>();<br>    ~<span class="hljs-built_in">GoogCcNetworkController</span>() <span class="hljs-keyword">override</span>;<br><br>    <span class="hljs-function">webrtc::NetworkControlUpdate <span class="hljs-title">OnTransportPacketsFeedback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> webrtc::TransportPacketsFeedback&amp; report)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;DelayBasedBwe&gt; delay_base_bwe_;<br>&#125;;<br><br>&#125; <span class="hljs-comment">// namespace xrtc</span><br><span class="hljs-comment">//xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\goog_cc_network_controller.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xrtc/rtc/modules/congestion_controller/goog_cc/goog_cc_network_controller.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> xrtc &#123;<br><br>GoogCcNetworkController::<span class="hljs-built_in">GoogCcNetworkController</span>() :<br>    <span class="hljs-built_in">delay_base_bwe_</span>(std::<span class="hljs-built_in">make_unique</span>&lt;DelayBasedBwe&gt;())<br>&#123;<br>&#125;<br><br>GoogCcNetworkController::~<span class="hljs-built_in">GoogCcNetworkController</span>() &#123;<br>&#125;<br><br><span class="hljs-function">webrtc::NetworkControlUpdate <span class="hljs-title">GoogCcNetworkController::OnTransportPacketsFeedback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> webrtc::TransportPacketsFeedback&amp; report)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (report.packet_feedbacks.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> webrtc::<span class="hljs-built_in">NetworkControlUpdate</span>();<br>    &#125;<br><br>    DelayBasedBwe::Result result;<br>    result = delay_base_bwe_-&gt;<span class="hljs-built_in">IncomingPacketFeedbackVector</span>(report);<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace xrtc</span><br><span class="hljs-comment">//xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\delay_based_bwe.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;api/transport/network_types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;api/units/data_rate.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> xrtc &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayBasedBwe</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Result</span> &#123;<br>        <span class="hljs-type">bool</span> updated = <span class="hljs-literal">false</span>;<br>        webrtc::DataRate target_bitrate = webrtc::DataRate::<span class="hljs-built_in">Zero</span>();<br>    &#125;;<br><br>    <span class="hljs-built_in">DelayBasedBwe</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DelayBasedBwe</span>();<br><br>    <span class="hljs-function">Result <span class="hljs-title">IncomingPacketFeedbackVector</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> webrtc::TransportPacketsFeedback&amp; msg)</span></span>;<br>&#125;;<br><br>&#125; <span class="hljs-comment">// namespace xrtc</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// XRTCSDK_XRTC_RTC_MODULES_CONGESTION_CONTROLLER_GOOG_CC_DELAY_BASED_BWE_H_</span></span><br><span class="hljs-comment">//xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\delay_based_bwe.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xrtc/rtc/modules/congestion_controller/goog_cc/delay_based_bwe.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> xrtc &#123;<br><br>DelayBasedBwe::<span class="hljs-built_in">DelayBasedBwe</span>() &#123;<br>&#125;<br>DelayBasedBwe::~<span class="hljs-built_in">DelayBasedBwe</span>() &#123;<br>&#125;<br><br><span class="hljs-function">DelayBasedBwe::Result <span class="hljs-title">DelayBasedBwe::IncomingPacketFeedbackVector</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> webrtc::TransportPacketsFeedback&amp; msg)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> DelayBasedBwe::<span class="hljs-built_in">Result</span>();<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace xrtc</span><br></code></pre></td></tr></table></figure><h2 id="包组延迟差的计算"><a href="#包组延迟差的计算" class="headerlink" title="包组延迟差的计算"></a>包组延迟差的计算</h2><p>由于单个数据包的延迟差抖动较大，所以取一段时间的包作为一组，取分组的平均时间来计算延迟差。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\inter_arrival_delta.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;api/units/time_delta.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;api/units/timestamp.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> xrtc &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterArrivalDelta</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">InterArrivalDelta</span>(webrtc::TimeDelta send_time_group_length);<br>    ~<span class="hljs-built_in">InterArrivalDelta</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ComputeDeltas</span><span class="hljs-params">(webrtc::Timestamp send_time,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp arrival_time,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp system_time,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">size_t</span> packet_size,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::TimeDelta* send_time_delta,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::TimeDelta* arrival_time_delta,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span>* packet_size_delta)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 包组结构体</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SendTimeGroup</span> &#123;<br>        <span class="hljs-built_in">SendTimeGroup</span>() :<br>            <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>),<br>            <span class="hljs-built_in">first_send_time</span>(webrtc::Timestamp::<span class="hljs-built_in">MinusInfinity</span>()),<br>            <span class="hljs-built_in">send_time</span>(webrtc::Timestamp::<span class="hljs-built_in">MinusInfinity</span>()),<br>            <span class="hljs-built_in">first_arrival</span>(webrtc::Timestamp::<span class="hljs-built_in">MinusInfinity</span>()),<br>            <span class="hljs-built_in">complete_time</span>(webrtc::Timestamp::<span class="hljs-built_in">MinusInfinity</span>()),<br>            <span class="hljs-built_in">last_system_time</span>(webrtc::Timestamp::<span class="hljs-built_in">MinusInfinity</span>()) <br>        &#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFirstPacket</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-comment">// 通过完成时间是否有值判断是否是第一个包</span><br>            <span class="hljs-keyword">return</span> complete_time.<span class="hljs-built_in">IsInfinite</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 分组中所有包的累计字节数</span><br>        <span class="hljs-type">size_t</span> size;<br>        <span class="hljs-comment">// 分组第一个包的发送时间</span><br>        webrtc::Timestamp first_send_time;<br>        <span class="hljs-comment">// 分组最后一个包的发送时间</span><br>        webrtc::Timestamp send_time;<br>        <span class="hljs-comment">// 分组中第一个达到接收端的包的时间</span><br>        webrtc::Timestamp first_arrival;<br>        <span class="hljs-comment">// 分组中最后一个达到接收端的包的时间</span><br>        webrtc::Timestamp complete_time;<br>        <span class="hljs-comment">// 最新的系统时间</span><br>        webrtc::Timestamp last_system_time;<br>    &#125;;<br>    <span class="hljs-comment">// 创建新的时间分组</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NewTimestampGroup</span><span class="hljs-params">(webrtc::Timestamp arrival_time,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp send_time)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 突发流判断，用来判断是否放在同一个分组内</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BelongsToBurst</span><span class="hljs-params">(webrtc::Timestamp arrival_time,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp send_time)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 重置包组</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reset</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    webrtc::TimeDelta send_time_group_length_;<span class="hljs-comment">// 包组长度</span><br>    SendTimeGroup current_timestamp_group_;   <span class="hljs-comment">// 当前包组</span><br>    SendTimeGroup prev_timestamp_group_;      <span class="hljs-comment">// 前一个包组</span><br>&#125;;<br><br>&#125; <span class="hljs-comment">// namespace xrtc</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// XRTCSDK_XRTC_RTC_MODULES_CONGESTION_CONTROLLER_GOOG_CC_INTER_ARRIVAL_DELTA_H_</span></span><br></code></pre></td></tr></table></figure><p>计算包组延迟差</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\inter_arrival_delta.cpp</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// return:bool</span><br><span class="hljs-comment">// 后三个参数用于返回计算的发送延迟差、到达延迟差、包大小差（什么作用？），利用这些参数计算单项延迟差。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterArrivalDelta::ComputeDeltas</span><span class="hljs-params">(webrtc::Timestamp send_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp arrival_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp system_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> packet_size, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::TimeDelta* send_time_delta, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::TimeDelta* arrival_time_delta, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span>* packet_size_delta)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> calculated_delta = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果是第一个包</span><br>    <span class="hljs-keyword">if</span> (current_timestamp_group_.<span class="hljs-built_in">IsFirstPacket</span>()) &#123;<br>        current_timestamp_group_.send_time = send_time;<br>        current_timestamp_group_.first_send_time = send_time;<br>        current_timestamp_group_.first_arrival = arrival_time;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (send_time &lt; current_timestamp_group_.send_time) &#123;<span class="hljs-comment">//发送时间早于分组的第一个包则舍弃</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果需要创建新的分组</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NewTimestampGroup</span>(arrival_time, send_time)) &#123; <br>        <span class="hljs-comment">// 判断是否需要计算两个包组之间的时间差</span><br>        <span class="hljs-keyword">if</span> (prev_timestamp_group_.complete_time.<span class="hljs-built_in">IsFinite</span>()) &#123;<br>        <span class="hljs-comment">// 前一个分组的完成时间有值（前一个包组有效），则接下来完成该分组的时间计算</span><br>            *send_time_delta = current_timestamp_group_.send_time -<br>                prev_timestamp_group_.send_time;<br>            *arrival_time_delta = current_timestamp_group_.complete_time -<br>                prev_timestamp_group_.complete_time;<br>            webrtc::TimeDelta system_time_delta = current_timestamp_group_.last_system_time -<br>                prev_timestamp_group_.last_system_time;<br>            <span class="hljs-keyword">if</span> (*arrival_time_delta - system_time_delta &gt;=<br>                kArrivalTimeOffsetThreshold) <span class="hljs-comment">//??? 分组无效，重置分组</span><br>            &#123;<br>                <span class="hljs-built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="hljs-string">&quot;Arrival time clock offset has changed, &quot;</span><br>                    &lt;&lt; <span class="hljs-string">&quot;diff: &quot;</span> &lt;&lt; arrival_time_delta-&gt;<span class="hljs-built_in">ms</span>() - system_time_delta.<span class="hljs-built_in">ms</span>()<br>                    &lt;&lt; <span class="hljs-string">&quot;, resetting&quot;</span>;<br>                <span class="hljs-built_in">Reset</span>();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 当前分组已结束且已完成时间差计算</span><br>        *packet_size_delta = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(current_timestamp_group_.size -<br>            prev_timestamp_group_.size);<br>        calculated_delta = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 初始化下一个分组</span><br>        prev_timestamp_group_ = current_timestamp_group_;<br>        current_timestamp_group_.first_send_time = send_time;<br>        current_timestamp_group_.send_time = send_time;<br>        current_timestamp_group_.first_arrival = arrival_time;<br>        current_timestamp_group_.size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 更新当前分组的包的发送时间</span><br>        current_timestamp_group_.send_time =<br>            std::<span class="hljs-built_in">max</span>(current_timestamp_group_.send_time, send_time);<br>    &#125;<br><br>    <span class="hljs-comment">// 累计分组的包大小，更新最新的到达时间和系统时间</span><br>    current_timestamp_group_.size += packet_size;<br>    current_timestamp_group_.complete_time = arrival_time;<br>    current_timestamp_group_.last_system_time = system_time;<br><br>    <span class="hljs-keyword">return</span> calculated_delta;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 判断是否需要建立新的分组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterArrivalDelta::NewTimestampGroup</span><span class="hljs-params">(webrtc::Timestamp arrival_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp send_time)</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (current_timestamp_group_.complete_time.<span class="hljs-built_in">IsInfinite</span>()) &#123;<span class="hljs-comment">// 当前分组未完成</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 突发的包要分为一组，而不去创建新组</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">BelongsToBurst</span>(arrival_time, send_time)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 分组时间跨度不能超过阈值</span><br>        <span class="hljs-keyword">return</span> send_time - current_timestamp_group_.first_send_time &gt;<br>            send_time_group_length_;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 判断当前包是否属于当前分组的突发流的一员</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterArrivalDelta::BelongsToBurst</span><span class="hljs-params">(webrtc::Timestamp arrival_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp send_time)</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>    webrtc::TimeDelta arrival_time_delta =<br>        arrival_time - current_timestamp_group_.complete_time;<br>    webrtc::TimeDelta send_time_delta =<br>        send_time - current_timestamp_group_.send_time;<br>    <span class="hljs-comment">// 计算传播延迟差</span><br>    webrtc::TimeDelta propgation_delta = arrival_time_delta -<br>        send_time_delta;<br><br>    <span class="hljs-keyword">if</span> (send_time_delta.<span class="hljs-built_in">IsZero</span>()) &#123; <span class="hljs-comment">// 发送时间相同的包</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 延迟差小于0，说明包提前到达了，说明该包跟前一个包一起到达，说明属于同一个burst</span><br>    <span class="hljs-comment">// 到达时间与最后一个包的到达时间差小于阈值  或者 与分组中第一个包的到达时间差小于一个阈值 </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propgation_delta &lt; webrtc::TimeDelta::<span class="hljs-built_in">Zero</span>() &amp;&amp;<br>        arrival_time_delta &lt; kBurstDeltaThreshold &amp;&amp;<br>        arrival_time - current_timestamp_group_.first_arrival<br>        &lt; kMaxBurstDuration) <br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterArrivalDelta::Reset</span><span class="hljs-params">()</span> </span>&#123;<br>    current_timestamp_group_ = <span class="hljs-built_in">SendTimeGroup</span>();<br>    prev_timestamp_group_ = <span class="hljs-built_in">SendTimeGroup</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在delay_based_bwe.cpp文件中调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\delay_based_bwe.cpp</span><br><span class="hljs-function">DelayBasedBwe::Result <span class="hljs-title">DelayBasedBwe::IncomingPacketFeedbackVector</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> webrtc::TransportPacketsFeedback&amp; msg)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 数据包按照到达时间进行排序</span><br>    <span class="hljs-keyword">auto</span> packet_feedback_vector = msg.<span class="hljs-built_in">SortedByReceiveTime</span>();<br>    <span class="hljs-keyword">if</span> (packet_feedback_vector.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> DelayBasedBwe::<span class="hljs-built_in">Result</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; packet_feedback : packet_feedback_vector) &#123;<br>        <span class="hljs-built_in">IncomingPacketFeedback</span>(packet_feedback, msg.feedback_time);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> DelayBasedBwe::<span class="hljs-built_in">Result</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DelayBasedBwe::IncomingPacketFeedback</span><span class="hljs-params">(<span class="hljs-type">const</span> webrtc::PacketResult&amp; packet_feedback, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果是第一次收到packet，需要创建计算包组时间差的对象</span><br>    <span class="hljs-comment">// 如果长时间没有收到packet超过一定的阈值，需要重新创建对象</span><br>    <span class="hljs-keyword">if</span> (last_seen_timestamp_.<span class="hljs-built_in">IsInfinite</span>() ||<br>        at_time - last_seen_timestamp_ &gt; kStreamTimeout) <br>    &#123;<br>        video_inter_arrival_delta_ = std::<span class="hljs-built_in">make_unique</span>&lt;InterArrivalDelta&gt;(<br>            kSendTimeGroupLength);<br>    &#125;<br><br>    last_seen_timestamp_ = at_time;<br><br>    <span class="hljs-type">size_t</span> packet_size = packet_feedback.sent_packet.size.<span class="hljs-built_in">bytes</span>();<br><br>    webrtc::TimeDelta send_time_delta = webrtc::TimeDelta::<span class="hljs-built_in">Zero</span>();<br>    webrtc::TimeDelta recv_time_delta = webrtc::TimeDelta::<span class="hljs-built_in">Zero</span>();<br>    <span class="hljs-type">int</span> packet_size_delta = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算延迟差</span><br>    <span class="hljs-type">bool</span> calculated_delta = video_inter_arrival_delta_-&gt;<span class="hljs-built_in">ComputeDeltas</span>(<br>        packet_feedback.sent_packet.send_time,<br>        packet_feedback.receive_time,<br>        at_time,<br>        packet_size,<br>        &amp;send_time_delta, &amp;recv_time_delta, &amp;packet_size_delta);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="trendline估计器"><a href="#trendline估计器" class="headerlink" title="trendline估计器"></a>trendline估计器</h2><p>通过之前统计到的一系列延迟差数据，利用最小二乘法，估计出单项延迟变化趋势。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\delay_based_bwe.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DelayBasedBwe::IncomingPacketFeedback</span><span class="hljs-params">(<span class="hljs-type">const</span> webrtc::PacketResult&amp; packet_feedback, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果是第一次收到packet，需要创建计算包组时间差的对象</span><br>    <span class="hljs-comment">// 如果长时间没有收到packet超过一定的阈值，需要重新创建对象</span><br>    <span class="hljs-keyword">if</span> (last_seen_timestamp_.<span class="hljs-built_in">IsInfinite</span>() ||<br>        at_time - last_seen_timestamp_ &gt; kStreamTimeout) <br>    &#123;<br>        video_inter_arrival_delta_ = std::<span class="hljs-built_in">make_unique</span>&lt;InterArrivalDelta&gt;(<br>            kSendTimeGroupLength);<br>        <span class="hljs-comment">//video_delay_detector_.reset(new TrendlineEstimator());</span><br>    &#125;<br><br>    last_seen_timestamp_ = at_time;<br><br>    <span class="hljs-type">size_t</span> packet_size = packet_feedback.sent_packet.size.<span class="hljs-built_in">bytes</span>();<br><br>    webrtc::TimeDelta send_time_delta = webrtc::TimeDelta::<span class="hljs-built_in">Zero</span>();<br>    webrtc::TimeDelta recv_time_delta = webrtc::TimeDelta::<span class="hljs-built_in">Zero</span>();<br>    <span class="hljs-type">int</span> packet_size_delta = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">bool</span> calculated_delta = video_inter_arrival_delta_-&gt;<span class="hljs-built_in">ComputeDeltas</span>(<br>        packet_feedback.sent_packet.send_time,<br>        packet_feedback.receive_time,<br>        at_time,<br>        packet_size,<br>        &amp;send_time_delta, &amp;recv_time_delta, &amp;packet_size_delta);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    if (calculated_delta) &#123;</span><br><span class="hljs-comment">        RTC_LOG(LS_WARNING) &lt;&lt; &quot;**************send_delta: &quot; &lt;&lt; send_time_delta.ms()</span><br><span class="hljs-comment">            &lt;&lt; &quot;, recv_delta: &quot; &lt;&lt; recv_time_delta.ms()</span><br><span class="hljs-comment">            &lt;&lt; &quot;, packet_size_delta: &quot; &lt;&lt; packet_size_delta;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 更新延迟trendline</span><br>    video_delay_detector_-&gt;<span class="hljs-built_in">Update</span>(recv_time_delta, send_time_delta,<br>        packet_feedback.sent_packet.send_time,<br>        packet_feedback.receive_time,<br>        packet_size,<br>        calculated_delta);<br>&#125;<br></code></pre></td></tr></table></figure><p>在计算完成单项延迟差后，通过以下函数更新trendline</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TrendlineEstimator::Update</span><span class="hljs-params">(webrtc::TimeDelta recv_time_delta, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::TimeDelta send_time_delta, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp send_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp arrival_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> packet_size, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> calculated_delta)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (calculated_delta) &#123;<br>        <span class="hljs-built_in">UpdateTrendline</span>(recv_time_delta.<span class="hljs-built_in">ms</span>&lt;<span class="hljs-type">double</span>&gt;(),<br>            send_time_delta.<span class="hljs-built_in">ms</span>&lt;<span class="hljs-type">double</span>&gt;(),<br>            send_time.<span class="hljs-built_in">ms</span>(), arrival_time.<span class="hljs-built_in">ms</span>(),<br>            packet_size);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TrendlineEstimator::UpdateTrendline</span><span class="hljs-params">(<span class="hljs-type">double</span> recv_delta_ms, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span> send_delta_ms, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int64_t</span> send_time_ms, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int64_t</span> arrival_time_ms, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> packet_size)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == first_arrival_time_ms_) &#123;<br>        first_arrival_time_ms_ = arrival_time_ms;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计样本的个数</span><br>    ++num_of_deltas_;<br><br>    <span class="hljs-comment">// 计算传输的延迟差</span><br>    <span class="hljs-type">double</span> delta_ms = recv_delta_ms - send_delta_ms;<br>    accumulated_delay_ms_ += delta_ms;<br>    <span class="hljs-comment">// 计算指数平滑后的累计延迟差</span><br>    smoothed_delay_ms_ = smoothing_coef_ * smoothed_delay_ms_ +<br>        (<span class="hljs-number">1</span> - smoothing_coef_) * accumulated_delay_ms_;<br>    <span class="hljs-comment">// 将样本数据添加到队列</span><br>    delay_hist_.<span class="hljs-built_in">emplace_back</span>(<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(arrival_time_ms - first_arrival_time_ms_),<br>        smoothed_delay_ms_, accumulated_delay_ms_);<br><br>    <span class="hljs-keyword">if</span> (delay_hist_.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">20</span>) &#123;<br>        delay_hist_.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 当样本数据满足要求，计算trend值</span><br>    <span class="hljs-type">double</span> trend = prev_trend_;<br>    <span class="hljs-keyword">if</span> (delay_hist_.<span class="hljs-built_in">size</span>() == kDefaultTrendlineWindowSize) &#123;<br>        trend = <span class="hljs-built_in">LinearFitSlope</span>(delay_hist_).<span class="hljs-built_in">value_or</span>(trend);<span class="hljs-comment">//（LinearFitSlope(delay_hist_) | trend）</span><br>    &#125;<br><br>    <span class="hljs-comment">// 根据trend值进行过载检测</span><br>    <span class="hljs-built_in">Detect</span>(trend, send_delta_ms, arrival_time_ms);<br>&#125;<br><br><span class="hljs-comment">// 线性回归最小二乘法</span><br><span class="hljs-function">absl::optional&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">TrendlineEstimator::LinearFitSlope</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> std::deque&lt;PacketTiming&gt;&amp; packets)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> sum_x = <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-type">double</span> sum_y = <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; packet : packets) &#123;<br>        sum_x += packet.arrival_time_ms;<br>        sum_y += packet.smoothed_delay_ms;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算x，y的平均值</span><br>    <span class="hljs-type">double</span> avg_x = sum_x / packets.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">double</span> avg_y = sum_y / packets.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 分别计算分子和分母</span><br>    <span class="hljs-type">double</span> num = <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-type">double</span> den = <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; packet : packets) &#123;<br>        <span class="hljs-type">double</span> x = packet.arrival_time_ms;<br>        <span class="hljs-type">double</span> y = packet.smoothed_delay_ms;<br><br>        num += (x - avg_x) * (y - avg_y);<br>        den += (x - avg_x) * (x - avg_x);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0.0f</span> == den) &#123;<br>        <span class="hljs-keyword">return</span> absl::<span class="hljs-literal">nullopt</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> num / den;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TrendlineEstimator::Detect</span><span class="hljs-params">(<span class="hljs-type">double</span> trend, <span class="hljs-type">double</span> ts_delta, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int64_t</span> now_ms)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (num_of_deltas_ &lt; <span class="hljs-number">2</span>) &#123;<br>        hypothesis_ = webrtc::BandwidthUsage::kBwNormal;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 对原始的trend值进行增益处理，增加区分度</span><br>    <span class="hljs-type">double</span> modified_trend =<br>        std::<span class="hljs-built_in">min</span>(num_of_deltas_, kMinNumDeltas) * trend * threshold_gain_;<br><br>    <span class="hljs-comment">// 2. 进行过载检测</span><br>    <span class="hljs-keyword">if</span> (modified_trend &gt; threshold_) &#123; <span class="hljs-comment">// 有可能过载了</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == time_over_using_) &#123; <span class="hljs-comment">// 第一次超过阈值</span><br>            time_over_using_ = ts_delta / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            time_over_using_ += ts_delta;<br>        &#125;<br><br>        ++overuse_counter_;<br><br>        <span class="hljs-keyword">if</span> (time_over_using_ &gt; kOverUsingTimeThreshold &amp;&amp; overuse_counter_ &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (trend &gt; prev_trend_) &#123;<br>                <span class="hljs-comment">// 判定过载</span><br>                time_over_using_ = <span class="hljs-number">0</span>;<br>                overuse_counter_ = <span class="hljs-number">0</span>;<br>                hypothesis_ = webrtc::BandwidthUsage::kBwOverusing;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (modified_trend &lt; -threshold_) &#123;<br>        <span class="hljs-comment">// 判定负载过低了</span><br>        time_over_using_ = <span class="hljs-number">-1</span>;<br>        overuse_counter_ = <span class="hljs-number">0</span>;<br>        hypothesis_ = webrtc::BandwidthUsage::kBwUnderusing;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 判定正常网络状态</span><br>        time_over_using_ = <span class="hljs-number">-1</span>;<br>        overuse_counter_ = <span class="hljs-number">0</span>;<br>        hypothesis_ = webrtc::BandwidthUsage::kBwNormal;<br>    &#125;<br><br>    prev_trend_ = trend;<br><br>    <span class="hljs-comment">// 阈值的动态自适应调整</span><br>    <span class="hljs-built_in">UpdateThreshold</span>(modified_trend, now_ms);<br><br>    <span class="hljs-comment">// for test</span><br>    x_time_ &lt;&lt; now_ms - first_arrival_time_ms_ &lt;&lt; std::endl;<br>    y_trend_ &lt;&lt; modified_trend &lt;&lt; std::endl;<br>    y_threshold_ &lt;&lt; threshold_ &lt;&lt; std::endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TrendlineEstimator::UpdateThreshold</span><span class="hljs-params">(<span class="hljs-type">double</span> modified_trend, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int64_t</span> now_ms)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == last_update_ms_) &#123;<br>        last_update_ms_ = now_ms;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果modified_trend异常大的时候，忽略本次更新</span><br>    <span class="hljs-keyword">if</span> (modified_trend &gt; threshold_ + kMaxAdaptOffset) &#123;<br>        last_update_ms_ = now_ms;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 调整阈值，当阈值调小的时候，使用的系数0.039</span><br>    <span class="hljs-comment">// 当阈值调大的时候，使用的系数是0.0087</span><br>    <span class="hljs-type">double</span> k = <span class="hljs-built_in">fabs</span>(modified_trend) &lt; threshold_ ? k_down_ : k_up_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> kMaxTimeDelta = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int64_t</span> time_delta_ms = std::<span class="hljs-built_in">min</span>(now_ms - last_update_ms_, kMaxTimeDelta);<br>    threshold_ += k * (<span class="hljs-built_in">fabs</span>(modified_trend) - threshold_) * time_delta_ms;<br>    threshold_ = rtc::<span class="hljs-built_in">SafeClamp</span>(threshold_, <span class="hljs-number">6.0f</span>, <span class="hljs-number">600.0f</span>);<br>    last_update_ms_ = now_ms;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AIMD码率控制"><a href="#AIMD码率控制" class="headerlink" title="AIMD码率控制"></a>AIMD码率控制</h2><p>AIMD（Additive Increase Multiplicative Decrease）码率控制，指的是<strong>加性增加</strong>，<strong>乘性减少</strong>。当网络过载时，以乘性的方式减少码率；当网络没有过载时，以加性的方式增加码率。另外，当我们认为可用带宽发生了变化或者未知时，会切换到慢启动模式，此种模式会以倍速的方式增加码率。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\delay_based_bwe.cpp</span><br><span class="hljs-function">DelayBasedBwe::Result <span class="hljs-title">DelayBasedBwe::IncomingPacketFeedbackVector</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> webrtc::TransportPacketsFeedback&amp; msg,</span></span><br><span class="hljs-params"><span class="hljs-function">    absl::optional&lt;webrtc::DataRate&gt; acked_bitrate)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 数据包按照到达时间进行排序</span><br>    <span class="hljs-keyword">auto</span> packet_feedback_vector = msg.<span class="hljs-built_in">SortedByReceiveTime</span>();<br>    <span class="hljs-keyword">if</span> (packet_feedback_vector.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> DelayBasedBwe::<span class="hljs-built_in">Result</span>();<br>    &#125;<br><br>    <span class="hljs-type">bool</span> recover_from_overusing = <span class="hljs-literal">false</span>;<br>    webrtc::BandwidthUsage prev_detector_state = video_delay_detector_-&gt;<span class="hljs-built_in">State</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; packet_feedback : packet_feedback_vector) &#123;<br>        <span class="hljs-built_in">IncomingPacketFeedback</span>(packet_feedback, msg.feedback_time);<br>        <span class="hljs-keyword">if</span> (prev_detector_state == webrtc::BandwidthUsage::kBwUnderusing &amp;&amp;<br>            video_delay_detector_-&gt;<span class="hljs-built_in">State</span>() == webrtc::BandwidthUsage::kBwNormal) <br>        &#123;<br>            recover_from_overusing = <span class="hljs-literal">true</span>;<span class="hljs-comment">//表示从拥塞状态恢复到了正常</span><br>        &#125;<br>        prev_detector_state = video_delay_detector_-&gt;<span class="hljs-built_in">State</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">MaybeUpdateEstimate</span>(acked_bitrate, recover_from_overusing, msg.feedback_time);<br>&#125;<br><br><span class="hljs-function">DelayBasedBwe::Result <span class="hljs-title">DelayBasedBwe::MaybeUpdateEstimate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    absl::optional&lt;webrtc::DataRate&gt; acked_bitrate,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> recover_from_overusing, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 根据网络检测状态来动态的调整发送码率</span><br>    Result result;<br>    <span class="hljs-comment">// 当网络出现过载的时候</span><br>    <span class="hljs-keyword">if</span> (video_delay_detector_-&gt;<span class="hljs-built_in">State</span>() == webrtc::BandwidthUsage::kBwOverusing) &#123;<br>        <span class="hljs-comment">// 已知吞吐量时</span><br>        <span class="hljs-keyword">if</span> (acked_bitrate &amp;&amp; rate_control_.<span class="hljs-built_in">TimeToReduceFurther</span>(at_time, *acked_bitrate)) &#123;<br>            result.updated = <span class="hljs-built_in">UpdateEstimate</span>(acked_bitrate, at_time, &amp;result.target_bitrate);<br>        &#125;<br>        <span class="hljs-comment">// 当我们不知道吞吐量的时候</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!acked_bitrate &amp;&amp; rate_control_.<span class="hljs-built_in">ValidEstimate</span>() &amp;&amp;<br>            rate_control_.<span class="hljs-built_in">InitialTimeToReduceFurther</span>(at_time))                 <br>        &#123;<br>            <span class="hljs-comment">// 当我们不知道吞吐量的时候，将当前的码率下降一半</span><br>            rate_control_.<span class="hljs-built_in">SetEstimate</span>(rate_control_.<span class="hljs-built_in">LatestEstimate</span>() / <span class="hljs-number">2</span>,<br>                at_time);<br>            result.updated = <span class="hljs-literal">true</span>;<br>            result.target_bitrate = rate_control_.<span class="hljs-built_in">LatestEstimate</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 网络没有出现过载</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        result.updated = <span class="hljs-built_in">UpdateEstimate</span>(acked_bitrate, at_time, &amp;result.target_bitrate);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DelayBasedBwe::UpdateEstimate</span><span class="hljs-params">(absl::optional&lt;webrtc::DataRate&gt; acked_bitrate, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::DataRate* target_bitrate)</span> </span><br><span class="hljs-function"></span>&#123;<br>    *target_bitrate = rate_control_.<span class="hljs-built_in">Update</span>(acked_bitrate,<br>        video_delay_detector_-&gt;<span class="hljs-built_in">State</span>(), at_time);<br>    <span class="hljs-keyword">return</span> rate_control_.<span class="hljs-built_in">ValidEstimate</span>();<br>&#125;<br><span class="hljs-comment">// xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\aimd_rate_control.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;api/units/data_rate.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;api/units/timestamp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;api/network_state_predictor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;absl/types/optional.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xrtc/rtc/modules/congestion_controller/goog_cc/link_capacity_estimator.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> xrtc &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AimdRateControl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AimdRateControl</span>();<br>    ~<span class="hljs-built_in">AimdRateControl</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetStartBitrate</span><span class="hljs-params">(webrtc::DataRate start_bitrate)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ValidEstimate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TimeToReduceFurther</span><span class="hljs-params">(webrtc::Timestamp at_time,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::DataRate estimated_throughput)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitialTimeToReduceFurther</span><span class="hljs-params">(webrtc::Timestamp at_time)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">webrtc::DataRate <span class="hljs-title">LatestEstimate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetRtt</span><span class="hljs-params">(webrtc::TimeDelta rtt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetEstimate</span><span class="hljs-params">(webrtc::DataRate new_bitrate, webrtc::Timestamp at_time)</span></span>;<br>    <span class="hljs-function">webrtc::DataRate <span class="hljs-title">Update</span><span class="hljs-params">(absl::optional&lt;webrtc::DataRate&gt; throughput_estimate,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::BandwidthUsage state,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp at_time)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">RateControlState</span> &#123;<br>        kRcHold,     <span class="hljs-comment">// 保持码率不变</span><br>        kRcIncrease, <span class="hljs-comment">// 增加码率</span><br>        kRcDecrease, <span class="hljs-comment">// 降低码率</span><br>    &#125;;<br><br>    <span class="hljs-function">webrtc::DataRate <span class="hljs-title">ClampBitrate</span><span class="hljs-params">(webrtc::DataRate new_bitrate)</span></span>;<br>    <span class="hljs-function">webrtc::DataRate <span class="hljs-title">AdditiveRateIncrease</span><span class="hljs-params">(webrtc::Timestamp at_time,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp last_time)</span></span>;<br>    <span class="hljs-function">webrtc::DataRate <span class="hljs-title">MultiplicativeRateIncrease</span><span class="hljs-params">(webrtc::Timestamp at_time,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp last_time)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetNearMaxIncreaseRateBpsPerSecond</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChangeBitrate</span><span class="hljs-params">(absl::optional&lt;webrtc::DataRate&gt; throughput_estimate,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::BandwidthUsage state,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp at_time)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChangeState</span><span class="hljs-params">(webrtc::BandwidthUsage state,</span></span><br><span class="hljs-params"><span class="hljs-function">        webrtc::Timestamp at_time)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    webrtc::DataRate min_config_bitrate_;<br>    webrtc::DataRate max_config_bitrate_;<br>    webrtc::DataRate current_bitrate_;<br>    webrtc::DataRate latest_estimated_throughput_;<br>    <span class="hljs-type">bool</span> bitrate_is_init_ = <span class="hljs-literal">false</span>;<br>    webrtc::TimeDelta rtt_;<br>    <span class="hljs-type">double</span> beta_;<br>    webrtc::Timestamp time_last_bitrate_change_ = webrtc::Timestamp::<span class="hljs-built_in">MinusInfinity</span>();<br>    webrtc::Timestamp time_last_bitrate_decrease_ = webrtc::Timestamp::<span class="hljs-built_in">MinusInfinity</span>();<br>    webrtc::Timestamp time_first_throughput_estimate_ = webrtc::Timestamp::<span class="hljs-built_in">MinusInfinity</span>();<br>    RateControlState rate_control_state_ = RateControlState::kRcHold;<br>    LinkCapacityEstimator link_capacity_;<br>&#125;;<br><br>&#125; <span class="hljs-comment">// namespace xrtc</span><br><span class="hljs-comment">// xrtcsdk_gcc\xrtc\rtc\modules\congestion_controller\goog_cc\aimd_rate_control.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xrtc/rtc/modules/congestion_controller/goog_cc/aimd_rate_control.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rtc_base/logging.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> xrtc &#123;<br><span class="hljs-keyword">namespace</span> &#123;<br><br><span class="hljs-keyword">constexpr</span> webrtc::TimeDelta kDefaultRtt = webrtc::TimeDelta::<span class="hljs-built_in">Millis</span>(<span class="hljs-number">200</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> kDefaultBackOffFractor = <span class="hljs-number">0.85</span>;<br><br>&#125; <span class="hljs-comment">// namespace</span><br><br>AimdRateControl::<span class="hljs-built_in">AimdRateControl</span>() :<br>    <span class="hljs-built_in">min_config_bitrate_</span>(webrtc::DataRate::<span class="hljs-built_in">KilobitsPerSec</span>(<span class="hljs-number">5</span>)),<br>    <span class="hljs-built_in">max_config_bitrate_</span>(webrtc::DataRate::<span class="hljs-built_in">KilobitsPerSec</span>(<span class="hljs-number">30000</span>)),<br>    <span class="hljs-built_in">current_bitrate_</span>(max_config_bitrate_),<br>    <span class="hljs-built_in">latest_estimated_throughput_</span>(current_bitrate_),<br>    <span class="hljs-built_in">rtt_</span>(kDefaultRtt),<br>    <span class="hljs-built_in">beta_</span>(kDefaultBackOffFractor)<br>&#123;<br>&#125;<br><br>AimdRateControl::~<span class="hljs-built_in">AimdRateControl</span>() &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AimdRateControl::SetStartBitrate</span><span class="hljs-params">(webrtc::DataRate start_bitrate)</span> </span>&#123;<br>    current_bitrate_ = start_bitrate;<br>    bitrate_is_init_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AimdRateControl::ValidEstimate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> bitrate_is_init_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AimdRateControl::TimeToReduceFurther</span><span class="hljs-params">(webrtc::Timestamp at_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::DataRate estimated_throughput)</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 为了防止码率降低的过于频繁，需要控制码率降低的频率</span><br>    <span class="hljs-comment">// 两次码率降低的间隔，要大于1个RTT</span><br>    webrtc::TimeDelta bitrate_reduction_interval =<br>        rtt_.<span class="hljs-built_in">Clamped</span>(webrtc::TimeDelta::<span class="hljs-built_in">Millis</span>(<span class="hljs-number">10</span>),<br>            webrtc::TimeDelta::<span class="hljs-built_in">Millis</span>(<span class="hljs-number">200</span>));<br>    <span class="hljs-keyword">if</span> (at_time - time_last_bitrate_change_ &gt;= rtt_) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前码率的一半必须要大于吞吐量，避免码率降得过低</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ValidEstimate</span>()) &#123;<br>        webrtc::DataRate threshold = <span class="hljs-built_in">LatestEstimate</span>() * <span class="hljs-number">0.5</span>;<br>        <span class="hljs-keyword">return</span> estimated_throughput &lt; threshold;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AimdRateControl::InitialTimeToReduceFurther</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time)</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ValidEstimate</span>() &amp;&amp; <span class="hljs-built_in">TimeToReduceFurther</span>(at_time,<br>        <span class="hljs-built_in">LatestEstimate</span>() / <span class="hljs-number">2</span> - webrtc::DataRate::<span class="hljs-built_in">BitsPerSec</span>(<span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-function">webrtc::DataRate <span class="hljs-title">AimdRateControl::LatestEstimate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> current_bitrate_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AimdRateControl::SetRtt</span><span class="hljs-params">(webrtc::TimeDelta rtt)</span> </span>&#123;<br>    rtt_ = rtt;<br>    <span class="hljs-built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="hljs-string">&quot;==========rtt: &quot;</span> &lt;&lt; rtt.<span class="hljs-built_in">ms</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AimdRateControl::SetEstimate</span><span class="hljs-params">(webrtc::DataRate new_bitrate, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    bitrate_is_init_ = <span class="hljs-literal">true</span>;<br>    webrtc::DataRate prev_bitrate = current_bitrate_;<br>    current_bitrate_ = <span class="hljs-built_in">ClampBitrate</span>(new_bitrate);<br>    time_last_bitrate_change_ = at_time;<br>    <span class="hljs-keyword">if</span> (current_bitrate_ &lt; prev_bitrate) &#123;<br>        time_last_bitrate_decrease_ = at_time;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">webrtc::DataRate <span class="hljs-title">AimdRateControl::Update</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    absl::optional&lt;webrtc::DataRate&gt; throughput_estimate, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::BandwidthUsage state, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!bitrate_is_init_) &#123;<br>        <span class="hljs-type">const</span> webrtc::TimeDelta kInitTime = webrtc::TimeDelta::<span class="hljs-built_in">Seconds</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">if</span> (time_first_throughput_estimate_.<span class="hljs-built_in">IsInfinite</span>()) &#123;<br>            time_first_throughput_estimate_ = at_time;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (at_time - time_first_throughput_estimate_ &gt; kInitTime<br>            &amp;&amp; throughput_estimate) <br>        &#123;<br>            current_bitrate_ = *throughput_estimate;<br>            bitrate_is_init_ = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">ChangeBitrate</span>(throughput_estimate, state, at_time);<br><br>    <span class="hljs-keyword">return</span> current_bitrate_;<br>&#125;<br><br><span class="hljs-function">webrtc::DataRate <span class="hljs-title">AimdRateControl::ClampBitrate</span><span class="hljs-params">(webrtc::DataRate new_bitrate)</span> </span>&#123;<br>    new_bitrate = std::<span class="hljs-built_in">max</span>(new_bitrate, min_config_bitrate_);<br>    <span class="hljs-keyword">return</span> new_bitrate;<br>&#125;<br><br><span class="hljs-function">webrtc::DataRate <span class="hljs-title">AimdRateControl::AdditiveRateIncrease</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp last_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> time_delta_seconds =<br>        (at_time - last_time).<span class="hljs-built_in">seconds</span>&lt;<span class="hljs-type">double</span>&gt;();<br>    <span class="hljs-type">double</span> increase_rate_bps  =<br>        <span class="hljs-built_in">GetNearMaxIncreaseRateBpsPerSecond</span>() * time_delta_seconds;<br>    <span class="hljs-keyword">return</span> webrtc::DataRate::<span class="hljs-built_in">BitsPerSec</span>(increase_rate_bps);<br>&#125;<br><br><span class="hljs-function">webrtc::DataRate <span class="hljs-title">AimdRateControl::MultiplicativeRateIncrease</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp last_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> alpha = <span class="hljs-number">1.08</span>;<br>    <span class="hljs-keyword">if</span> (last_time.<span class="hljs-built_in">IsFinite</span>()) &#123;<br>        <span class="hljs-type">double</span> time_since_last_update =<br>            (at_time - last_time).<span class="hljs-built_in">seconds</span>&lt;<span class="hljs-type">double</span>&gt;();<br>        alpha = <span class="hljs-built_in">pow</span>(alpha, std::<span class="hljs-built_in">min</span>(time_since_last_update, <span class="hljs-number">1.0</span>));<br>    &#125;<br><br>    webrtc::DataRate multiplicative_increase =<br>        std::<span class="hljs-built_in">max</span>(current_bitrate_ * (alpha - <span class="hljs-number">1.0</span>), <br>            webrtc::DataRate::<span class="hljs-built_in">BitsPerSec</span>(<span class="hljs-number">1000</span>));<br><br>    <span class="hljs-keyword">return</span> multiplicative_increase;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">AimdRateControl::GetNearMaxIncreaseRateBpsPerSecond</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">const</span> webrtc::TimeDelta kFrameInterval = webrtc::TimeDelta::<span class="hljs-built_in">Seconds</span>(<span class="hljs-number">1</span>) / <span class="hljs-number">30</span>;<br>    webrtc::DataSize frame_size = current_bitrate_ * kFrameInterval;<br>    <span class="hljs-type">const</span> webrtc::DataSize packet_size = webrtc::DataSize::<span class="hljs-built_in">Bytes</span>(<span class="hljs-number">1200</span>);<br>    <span class="hljs-type">double</span> packets_per_frame = std::<span class="hljs-built_in">ceil</span>(frame_size / packet_size);<br>    webrtc::DataSize avg_packet_size = frame_size / packets_per_frame;<br><br>    <span class="hljs-comment">// 100ms表示网络过载时增加的延迟</span><br>    webrtc::TimeDelta response_time = rtt_ + webrtc::TimeDelta::<span class="hljs-built_in">Millis</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-type">double</span> increase_rate_bps_per_second =<br>        (avg_packet_size / response_time).<span class="hljs-built_in">bps</span>&lt;<span class="hljs-type">double</span>&gt;();<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> kMinIncreaseRateBps = <span class="hljs-number">4000</span>;<br><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(kMinIncreaseRateBps, increase_rate_bps_per_second);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AimdRateControl::ChangeBitrate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    absl::optional&lt;webrtc::DataRate&gt; acked_bitrate, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::BandwidthUsage state, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    absl::optional&lt;webrtc::DataRate&gt; new_bitrate;<br>    webrtc::DataRate estimated_throughput =<br>        acked_bitrate.<span class="hljs-built_in">value_or</span>(latest_estimated_throughput_);<br>    <span class="hljs-comment">// 更新最新的吞吐量</span><br>    <span class="hljs-keyword">if</span> (acked_bitrate) &#123;<br>        latest_estimated_throughput_ = *acked_bitrate;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前网络状态是过载状态，即使没有初始化起始码率，仍然需要降低码率</span><br>    <span class="hljs-keyword">if</span> (!bitrate_is_init_ &amp;&amp; state != webrtc::BandwidthUsage::kBwOverusing) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">ChangeState</span>(state, at_time);<br><br>    <span class="hljs-comment">// 为了防止码率无限制的增加，码率增加的上限设置为吞吐量的1.5倍 + 10k</span><br>    webrtc::DataRate throughput_base_limit =<br>        estimated_throughput * <span class="hljs-number">1.5</span> + webrtc::DataRate::<span class="hljs-built_in">KilobitsPerSec</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">switch</span> (rate_control_state_) &#123;<br>    <span class="hljs-keyword">case</span> RateControlState::kRcHold:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> RateControlState::kRcIncrease:<br>        <span class="hljs-comment">// 吞吐量已经超出了估计值的上限，估计值已经不可靠了，重置</span><br>        <span class="hljs-keyword">if</span> (estimated_throughput &gt; link_capacity_.<span class="hljs-built_in">UpperBound</span>()) &#123;<br>            link_capacity_.<span class="hljs-built_in">Reset</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current_bitrate_ &lt; throughput_base_limit) &#123;<br>            webrtc::DataRate increased_bitrate = webrtc::DataRate::<span class="hljs-built_in">MinusInfinity</span>();<br>            <span class="hljs-comment">// 如果当前的链路容量的估计值有效，表示我们的目标码率快接近最大容量</span><br>            <span class="hljs-comment">// 此时，码率的增加应该谨慎，采取加性增加的方式</span><br>            <span class="hljs-keyword">if</span> (link_capacity_.<span class="hljs-built_in">HasEstimate</span>()) &#123;<br>                webrtc::DataRate additive_increase =<br>                    <span class="hljs-built_in">AdditiveRateIncrease</span>(at_time, time_last_bitrate_change_);<br>                increased_bitrate = current_bitrate_ + additive_increase;<br>                <span class="hljs-built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="hljs-string">&quot;**************add_increase: &quot;</span> &lt;&lt; additive_increase.<span class="hljs-built_in">kbps</span>()<br>                    &lt;&lt; <span class="hljs-string">&quot;, increased_bitrate: &quot;</span> &lt;&lt; increased_bitrate.<span class="hljs-built_in">kbps</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 当链路容量未知时，采用乘性增加码率的方式</span><br>                <span class="hljs-comment">// 以快速发现容量</span><br>                webrtc::DataRate multiplicative_increase =<br>                    <span class="hljs-built_in">MultiplicativeRateIncrease</span>(at_time, time_last_bitrate_change_);<br>                increased_bitrate = current_bitrate_ + multiplicative_increase;<br>                <span class="hljs-built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="hljs-string">&quot;**************muliti_increase: &quot;</span> &lt;&lt; multiplicative_increase.<span class="hljs-built_in">kbps</span>()<br>                    &lt;&lt; <span class="hljs-string">&quot;, increased_bitrate: &quot;</span> &lt;&lt; increased_bitrate.<span class="hljs-built_in">kbps</span>();<br>            &#125;<br><br>            new_bitrate = std::<span class="hljs-built_in">min</span>(increased_bitrate, throughput_base_limit);<br>        &#125;<br><br>        time_last_bitrate_change_ = at_time;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> RateControlState::kRcDecrease: <br>    &#123;<br>        webrtc::DataRate decreased_bitrate = webrtc::DataRate::<span class="hljs-built_in">PlusInfinity</span>();<br>        decreased_bitrate = estimated_throughput * beta_;<br>        <span class="hljs-keyword">if</span> (decreased_bitrate &gt; current_bitrate_) &#123;<br>            <span class="hljs-keyword">if</span> (link_capacity_.<span class="hljs-built_in">HasEstimate</span>()) &#123;<br>                decreased_bitrate = link_capacity_.<span class="hljs-built_in">estimate</span>() * beta_;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 避免码率下降逻辑，当前码率反而升高了</span><br>        <span class="hljs-keyword">if</span> (decreased_bitrate &lt; current_bitrate_) &#123;<br>            new_bitrate = decreased_bitrate;<br>            <span class="hljs-built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="hljs-string">&quot;**************decreased_bitrate: &quot;</span> &lt;&lt; decreased_bitrate.<span class="hljs-built_in">kbps</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 吞吐量已经超出了估计值的下限，估计值已经不可靠了，重置</span><br>        <span class="hljs-keyword">if</span> (estimated_throughput &lt; link_capacity_.<span class="hljs-built_in">LowerBound</span>()) &#123;<br>            link_capacity_.<span class="hljs-built_in">Reset</span>();<br>        &#125;<br><br>        link_capacity_.<span class="hljs-built_in">OnOveruseDetected</span>(estimated_throughput);<br>        bitrate_is_init_ = <span class="hljs-literal">true</span>;<br>        rate_control_state_ = RateControlState::kRcHold;<br>        time_last_bitrate_change_ = at_time;<br>        time_last_bitrate_decrease_ = at_time;<br>    &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    current_bitrate_ = <span class="hljs-built_in">ClampBitrate</span>(new_bitrate.<span class="hljs-built_in">value_or</span>(current_bitrate_));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AimdRateControl::ChangeState</span><span class="hljs-params">(webrtc::BandwidthUsage state, </span></span><br><span class="hljs-params"><span class="hljs-function">    webrtc::Timestamp at_time)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (state) &#123;<br>    <span class="hljs-keyword">case</span> webrtc::BandwidthUsage::kBwNormal:<br>        <span class="hljs-keyword">if</span> (rate_control_state_ == RateControlState::kRcHold) &#123;<br>            rate_control_state_ = RateControlState::kRcIncrease;<br>            time_last_bitrate_change_ = at_time;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> webrtc::BandwidthUsage::kBwOverusing:<br>        <span class="hljs-keyword">if</span> (rate_control_state_ != RateControlState::kRcDecrease) &#123;<br>            rate_control_state_ = RateControlState::kRcDecrease;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> webrtc::BandwidthUsage::kBwUnderusing:<br>        rate_control_state_ = RateControlState::kRcHold;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace xrtc</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>带宽估计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虎牙、B站APP流量分析</title>
    <link href="/2024/03/07/%E8%99%8E%E7%89%99%E3%80%81B%E7%AB%99APP%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <url>/2024/03/07/%E8%99%8E%E7%89%99%E3%80%81B%E7%AB%99APP%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="虎牙直播"><a href="#虎牙直播" class="headerlink" title="虎牙直播"></a>虎牙直播</h2><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzk5OWY0Y2Q1ZTU2Mjg3YzQ3MmFhOWRkNzQ4OGEyZGFfbjVKaUhtVkRPVWFnMWd4NUZUT09UWFM1QWZscnpIM0FfVG9rZW46VFpCWWJMVkpTb0FuZk54TzFPSWNsZ2x3bndlXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>对于直播来说，拉流采用的时http-flv。在建立连接过程中，建立TCP连接以及发送GET请求即可。可以从历史的GET请求携带的中获取直播源并进行请求。</p><h2 id="B站直播"><a href="#B站直播" class="headerlink" title="B站直播"></a>B站直播</h2><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=YWM5Yjc0YmNmZTNhNDEyYjdhOTAzYmUwMzk3MGY4MjJfc21oUFgxMms2UUJ3S09VYzdab1Y4TXRXYWU3WjdOcDhfVG9rZW46T1NxZGJ3RlJyb1pBWkJ4blBGNGNwdnZMbnlnXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>建立连接的过程中需要建立TCP连接后进行协商tls加密信息。</p><p>对于断开重连的场景，有两种方式：</p><p>session id会话复用：对于已经建立的SSL会话，使用session id为key（session id来自第一次请求的server hello中的session id字段），主密钥为value组成一对键值，保存在本地，服务器和客户端都保存一份。</p><p>当第二次握手时，客户端若想使用会话复用，则发起的client hello中session id会置上对应的值，服务器收到这个client hello，<strong>解析session id，查找本地是否有该session id</strong>，如果有，判断当前的加密套件和上个会话的加密套件是否一致，一致则允许使用会话复用，于是自己的server hello 中session id也置上和client hello中一样的值。</p><p>session ticket会话复用：客户端和服务器端建立了一次完整的握手过程后，服务器端将本次的会话数据进行加密，例如会话标识符、证书、密码套件和主密钥等，加密后生成一个ticket票据，并将票据通过NewSessionTicket子消息发送给客户端，由客户端来保存，下一次连接时客户端如果希望恢复上一次会话而不是重新进行握手，就<strong>将“票据”一起发送给服务器端</strong>，待服务器端解密校验无误后，进行一次简短的握手，恢复上一次会话。</p><p>这种方式适用于重连的服务器变化的情况。</p><h2 id="B站点播"><a href="#B站点播" class="headerlink" title="B站点播"></a>B站点播</h2><p>基于UDP的DTLS、QUIC协议占主要部分。</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=MjczZDdlY2Y5OWRlNmM1ZWQxM2M3MDljNzM0ZjJhNzZfdFhtazhBbDdtNDQxYjlOSnBtZ25EcTlKY1FSUlVCZzlfVG9rZW46VzZxSGJoTTVkb3E5dHR4YXNrcGNkU25vblZoXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><p>对于推流，则以RTMP协议为主：</p><p>B站推流</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWE2ZDAwZjYwZjdlZDk1M2M3ODMwYzgwMGQ0OGNiMGFfUFZWUzlaUmpCNjI0RzV5Y3FBMWVTdkx3STlEWkNPNW5fVG9rZW46WE1Qd2JuRW81bzVtRld4RUpnUWMzOTVmbmVkXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>虎牙推流</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=NzQ5YzVlY2YzOTczNDEzMzFhOWEwOWU2NGJlNjM5YTlfV2hDZ2Q0RmR1b1dxVDZqdTNkcVQwNkd6a3IzeThhdjlfVG9rZW46TnhCcGIyZU92b2JoQ3R4TWZWZ2NHTDU2bmJkXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><h3 id="RTMP的建联过程"><a href="#RTMP的建联过程" class="headerlink" title="RTMP的建联过程"></a>RTMP的建联过程</h3><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFjYzc0ZWM0NDE3ODQyYmQ0ZDRkMzc4ZmIxY2E3NDRfanUxcXFSenp0SUdsaFkxZFFjUll2ZmpmemU1U3IzeDRfVG9rZW46Unp5bmJpMTRMbzVOVTR4UEg0NWM3c3dSbmxkXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>握手阶段</p><ul><li>客户端发送 C0+C1</li><li>服务端发送 S0+S1+S2</li><li>客户端发送 C2</li></ul><p>建立网络连接：服务端反馈确认窗口大小、带宽大小</p><ul><li>①、客户端发起连接请求</li><li>②、服务器设置客户端的应答窗口大小</li><li>③、服务器设置客户端的发送带宽大小</li><li>④、服务器设置客户端的接收块大小</li><li>⑤、服务器响应连接结果</li><li>⑥、客户端设置服务器的接收块大小</li></ul><p>建立网络流</p><ul><li>客户端发送命令消息中的“创建流” （createStream） 命令到服务器端。</li><li>服务器端接收到“创建流” 命令后， 发送命令消息中的“结果” (_result)， 通知客户端流的状态</li><li>客户端向服务器获取指定流的长度</li></ul><p>播放&#x2F;推流</p><ul><li>客户端发送命令消息中的“推流” （publish()） 命令到服务器。</li><li>服务器发送用户控制消息中的 “stream begin” ，告知客户端流 ID</li><li>服务器发送客户端要播放的音频和视频数据</li></ul><h2 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP-FLV"></a><strong>HTTP-FLV</strong></h2><p>HTTP-FLV 是将音视频数据以 FLV 文件格式进行封装，再将 FLV 格式数据封装在 HTTP 协议中进行传输的一种流媒体传输方式。</p><p>HTTP-FLV 被广泛采用的原因：</p><ol><li>HTTP 优点： a. 一些防火墙会墙掉 RTMP 或者其他的一些协议，但是防火墙对 HTTP 非常友好，不会墙掉 HTTP，因此基于 HTTP 传输的成功率更高。</li><li>FLV 优点： a. MP4、MKV 等封装格式将音视频数据和音视频元数据、索引、时间戳等分开存放，必须拿到完整的音视频文件才能播放，因为里面的单个音视频数据块不带有时间戳信息，播放器不能将这些没有时间戳信息的数据块连续起来，因此不能<strong>实时的解码</strong>播放。（当然 MP4 后来扩展了 FMP4 用于流媒体） b. FLV 格式的 FLV Tag Header 中携带时间戳，FLV 将每一帧音视频数据（Tag Body）封装成包含时间戳等音视频元数据（Tag Header）的数据包（Tag）。当播放器拿到 Tag 后，可根据时间戳等音视频元数据进行解码和播放。</li></ol><p>HTTP-FLV 的实现原理： HTTP-FLV 利用 HTTP&#x2F;1.1 分块传输机制发送 FLV 数据。虽然直播服务器无法知道直播流的长度，但是 HTTP&#x2F;1.1 分块传输机制可以不填写 <code>content-length</code> 字段而是携带 <code>Transfer-Encoding: chunked</code> 字段，这样客户端就会一直接受数据。</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFiMmRjMGQ3M2M3NGU1MzdlNjhlZDEwNzBiNGI3YTRfQjg1eDBmUVdPZUhYOXY4NkJkZzJJVmo3ejk0RmVXc1dfVG9rZW46UWdoZGJoeVF4bzRSbEV4UlJEZ2NhWDk0bmNoXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>解析后的协议使用的依然是http-flv</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=MmMyMjRkYWQwNjYzZmNjMDQyYWUyODAwNDU5NGE3N2FfZnRQaHM1ZEg5NjZ1Q2JvdE9lanhIaTBnbFZrS0t3Q05fVG9rZW46Um55RmJLZ2J2b1dSOGp4UXRoN2NpY3BZblFlXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>可以通过设置SSLKEYLOGFILE的环境变量， 就能够获取到每次对话产生的log文件。利用每次对话中，存储下来的log来解密报文。</p><p>设置SSLKEYLOGFILE环境变量</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjVjMGEzN2Q3ZDFmYzFjMDkxMWQzOTAwOGI4NjZmZmJfWE44S0ExVE9jbWExaVdBQjFVZXhDS1gzQkZ2WFJkaE1fVG9rZW46THd4VmJXY2Eyb3RBT2t4c3MxR2NKblBkbjJaXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>通过ssl.log中的client random(在TLS握手期间由客户端发送的随机非加密值)来标识会话，并从中获取对应的密钥。</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=MmE5MGNlNzA2ZDM1ODlhMWY1ZmIyYmEwODMzMGQzNmJfNnJkSTVxMFh2dTZwMjgxcDdqeTY1SWE2RExHcktRZVRfVG9rZW46UFZ3VmJ2RFdQbzBqS2F4dzJ4eGNFT05WbnBiXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>切换操作流程：</p><p>拉流端：http-flv</p><p>建立TCP连接；</p><p>建立TLS连接（对于B站APP）；</p><p>通过首次建立连接时收集到的session id或者是session ticket进行会话恢复。</p><p>发出HTTP-GET请求FLV视频数据；</p><p>通过历史信息获取直播源并生成URI请求。</p><p>推流端：RTMP</p><p>建立TCP连接；</p><p>RTMP握手；</p><p>建立网络连接：客户端与服务端交换确认窗口大小、带宽大小；</p><p>建立网络流；</p><p>设置SSLKEYLOGFILE环境变量</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=NjJmM2ZmNGQ1ZWE2YWEzYThhOTk0NzI2MTQyNjRkYjJfNVJWUXV1TG9jZ3g0dXU1b2hNMExBc2ZvTmtUWkNXaWVfVG9rZW46VUZheWJFbFE5b1Iyem54dzVZQmNEWWFMbmFnXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>在Wireshark中通过”编辑-&gt;首选项-&gt;Protocols-&gt;TLS“配置TLS协议中的(Pre)-Master-Secret log filename，将其配置成环境变量SSLKEYLOGFILE指向的log文件。</p><p><img src="https://d0xafjxiz1.feishu.cn/space/api/box/stream/download/asynccode/?code=N2YwZDBmNWI4MjdjZjI3MGI2YTEzOWQ3MWIwNTBjYjVfVWxkd2tlV1IyNG9xOHVDTzdUUzlFeFZ2OWV4Yzd4dFVfVG9rZW46Q2xJVmJkdlNsb2tmVUl4MUw3dGNFdmhkbjhkXzE3MDk4MDQ3NzE6MTcwOTgwODM3MV9WNA" alt="img"></p><p>再重新进行抓包即可解析出TLS文件。</p><p>对话窗不能是通过恢复协议而恢复的窗口， 报文中一定要包含有 <code>ClientKeyExchange</code>的握手消息</p><p><strong>如果是使用RSA密钥交换算法，那么报文中一定要包含ClientKeyExchange的消息， 这样wireshark 才能拿到客户端产生的随机数(预主密钥)，才能把密钥和报文匹配起来， 而恢复会话就很难确定之前的密钥是什么值了。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
